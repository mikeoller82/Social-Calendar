{"version":3,"file":"buffer.cjs","names":["headers: Record<string, string>","headerKeys","FlushResponse","expBackoff"],"sources":["../../../src/components/connect/buffer.ts"],"sourcesContent":["import debug, { type Debugger } from \"debug\";\nimport { headerKeys } from \"../../helpers/consts.ts\";\nimport { FlushResponse } from \"../../proto/src/components/connect/protobuf/connect.ts\";\nimport { expBackoff } from \"./util.ts\";\n\nexport class MessageBuffer {\n  private buffered: Record<string, Uint8Array> = {};\n  private pending: Record<string, Uint8Array> = {};\n  private getApiBaseUrl: () => Promise<string>;\n  private debug: Debugger;\n  private envName: string | undefined;\n\n  constructor({\n    envName,\n    getApiBaseUrl,\n  }: { envName: string | undefined; getApiBaseUrl: () => Promise<string> }) {\n    this.envName = envName;\n    this.getApiBaseUrl = getApiBaseUrl;\n    this.debug = debug(\"inngest:connect:message-buffer\");\n  }\n\n  public append(requestId: string, responseBytes: Uint8Array) {\n    this.buffered[requestId] = responseBytes;\n    delete this.pending[requestId];\n  }\n\n  public addPending(\n    requestId: string,\n    responseBytes: Uint8Array,\n    deadline: number,\n  ) {\n    this.pending[requestId] = responseBytes;\n    setTimeout(() => {\n      if (this.pending[requestId]) {\n        this.debug(\"Message not acknowledged in time\", requestId);\n        this.append(requestId, this.pending[requestId]!);\n      }\n    }, deadline);\n  }\n\n  public acknowledgePending(requestId: string) {\n    delete this.pending[requestId];\n  }\n\n  private async sendFlushRequest(\n    hashedSigningKey: string | undefined,\n    responseBytes: Uint8Array,\n  ) {\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/protobuf\",\n      ...(hashedSigningKey\n        ? { Authorization: `Bearer ${hashedSigningKey}` }\n        : {}),\n    };\n\n    if (this.envName) {\n      headers[headerKeys.Environment] = this.envName;\n    }\n\n    // protobuf's `finish()` is typed as `Uint8Array<ArrayBufferLike>` (could be\n    // SharedArrayBuffer-backed), but it actually creates a regular ArrayBuffer.\n    // Cast to satisfy fetch's stricter type requirement.\n    // const body = responseBytes as Uint8Array<ArrayBuffer>;\n    if (!isUnsharedArrayBuffer(responseBytes)) {\n      throw new Error(\"Unreachable: response bytes are not an ArrayBuffer\");\n    }\n\n    const resp = await fetch(\n      // refactor this to a more universal spot\n      new URL(\"/v0/connect/flush\", await this.getApiBaseUrl()),\n      {\n        method: \"POST\",\n        body: responseBytes,\n        headers: headers,\n      },\n    );\n\n    if (!resp.ok) {\n      this.debug(\"Failed to flush messages\", await resp.text());\n      throw new Error(\"Failed to flush messages\");\n    }\n\n    const flushResp = FlushResponse.decode(\n      new Uint8Array(await resp.arrayBuffer()),\n    );\n\n    return flushResp;\n  }\n\n  public async flush(hashedSigningKey: string | undefined) {\n    if (Object.keys(this.buffered).length === 0) {\n      return;\n    }\n\n    this.debug(`Flushing ${Object.keys(this.buffered).length} messages`);\n\n    const maxAttempts = 5;\n\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      for (const [k, v] of Object.entries(this.buffered)) {\n        try {\n          await this.sendFlushRequest(hashedSigningKey, v);\n          delete this.buffered[k];\n        } catch (err) {\n          this.debug(\"Failed to flush message\", k, err);\n          break;\n        }\n      }\n\n      if (Object.keys(this.buffered).length === 0) {\n        return;\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, expBackoff(attempt)));\n    }\n\n    this.debug(`Failed to flush messages after max attempts`, { maxAttempts });\n  }\n}\n\nfunction isUnsharedArrayBuffer(\n  value: Uint8Array<ArrayBufferLike>,\n): value is Uint8Array<ArrayBuffer> {\n  if (typeof SharedArrayBuffer === \"undefined\") {\n    // `SharedArrayBuffer` may not exist at runtime. Some runtimes removed it\n    // for security reasons (Spectre-like attacks).\n    //\n    // If it doesn't exist then we know value is an `ArrayBuffer`.\n    return true;\n  }\n\n  return value.buffer instanceof ArrayBuffer;\n}\n"],"mappings":";;;;;;;;AAKA,IAAa,gBAAb,MAA2B;CACzB,AAAQ,WAAuC,EAAE;CACjD,AAAQ,UAAsC,EAAE;CAChD,AAAQ;CACR,AAAQ;CACR,AAAQ;CAER,YAAY,EACV,SACA,iBACwE;AACxE,OAAK,UAAU;AACf,OAAK,gBAAgB;AACrB,OAAK,2BAAc,iCAAiC;;CAGtD,AAAO,OAAO,WAAmB,eAA2B;AAC1D,OAAK,SAAS,aAAa;AAC3B,SAAO,KAAK,QAAQ;;CAGtB,AAAO,WACL,WACA,eACA,UACA;AACA,OAAK,QAAQ,aAAa;AAC1B,mBAAiB;AACf,OAAI,KAAK,QAAQ,YAAY;AAC3B,SAAK,MAAM,oCAAoC,UAAU;AACzD,SAAK,OAAO,WAAW,KAAK,QAAQ,WAAY;;KAEjD,SAAS;;CAGd,AAAO,mBAAmB,WAAmB;AAC3C,SAAO,KAAK,QAAQ;;CAGtB,MAAc,iBACZ,kBACA,eACA;EACA,MAAMA,UAAkC;GACtC,gBAAgB;GAChB,GAAI,mBACA,EAAE,eAAe,UAAU,oBAAoB,GAC/C,EAAE;GACP;AAED,MAAI,KAAK,QACP,SAAQC,0BAAW,eAAe,KAAK;AAOzC,MAAI,CAAC,sBAAsB,cAAc,CACvC,OAAM,IAAI,MAAM,qDAAqD;EAGvE,MAAM,OAAO,MAAM,MAEjB,IAAI,IAAI,qBAAqB,MAAM,KAAK,eAAe,CAAC,EACxD;GACE,QAAQ;GACR,MAAM;GACG;GACV,CACF;AAED,MAAI,CAAC,KAAK,IAAI;AACZ,QAAK,MAAM,4BAA4B,MAAM,KAAK,MAAM,CAAC;AACzD,SAAM,IAAI,MAAM,2BAA2B;;AAO7C,SAJkBC,8BAAc,OAC9B,IAAI,WAAW,MAAM,KAAK,aAAa,CAAC,CACzC;;CAKH,MAAa,MAAM,kBAAsC;AACvD,MAAI,OAAO,KAAK,KAAK,SAAS,CAAC,WAAW,EACxC;AAGF,OAAK,MAAM,YAAY,OAAO,KAAK,KAAK,SAAS,CAAC,OAAO,WAAW;EAEpE,MAAM,cAAc;AAEpB,OAAK,IAAI,UAAU,GAAG,UAAU,aAAa,WAAW;AACtD,QAAK,MAAM,CAAC,GAAG,MAAM,OAAO,QAAQ,KAAK,SAAS,CAChD,KAAI;AACF,UAAM,KAAK,iBAAiB,kBAAkB,EAAE;AAChD,WAAO,KAAK,SAAS;YACd,KAAK;AACZ,SAAK,MAAM,2BAA2B,GAAG,IAAI;AAC7C;;AAIJ,OAAI,OAAO,KAAK,KAAK,SAAS,CAAC,WAAW,EACxC;AAGF,SAAM,IAAI,SAAS,YAAY,WAAW,SAASC,wBAAW,QAAQ,CAAC,CAAC;;AAG1E,OAAK,MAAM,+CAA+C,EAAE,aAAa,CAAC;;;AAI9E,SAAS,sBACP,OACkC;AAClC,KAAI,OAAO,sBAAsB,YAK/B,QAAO;AAGT,QAAO,MAAM,kBAAkB"}