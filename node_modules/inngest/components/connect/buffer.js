import { headerKeys } from "../../helpers/consts.js";
import { FlushResponse } from "../../proto/src/components/connect/protobuf/connect.js";
import { expBackoff } from "./util.js";
import debug from "debug";

//#region src/components/connect/buffer.ts
var MessageBuffer = class {
	buffered = {};
	pending = {};
	getApiBaseUrl;
	debug;
	envName;
	constructor({ envName, getApiBaseUrl }) {
		this.envName = envName;
		this.getApiBaseUrl = getApiBaseUrl;
		this.debug = debug("inngest:connect:message-buffer");
	}
	append(requestId, responseBytes) {
		this.buffered[requestId] = responseBytes;
		delete this.pending[requestId];
	}
	addPending(requestId, responseBytes, deadline) {
		this.pending[requestId] = responseBytes;
		setTimeout(() => {
			if (this.pending[requestId]) {
				this.debug("Message not acknowledged in time", requestId);
				this.append(requestId, this.pending[requestId]);
			}
		}, deadline);
	}
	acknowledgePending(requestId) {
		delete this.pending[requestId];
	}
	async sendFlushRequest(hashedSigningKey, responseBytes) {
		const headers = {
			"Content-Type": "application/protobuf",
			...hashedSigningKey ? { Authorization: `Bearer ${hashedSigningKey}` } : {}
		};
		if (this.envName) headers[headerKeys.Environment] = this.envName;
		if (!isUnsharedArrayBuffer(responseBytes)) throw new Error("Unreachable: response bytes are not an ArrayBuffer");
		const resp = await fetch(new URL("/v0/connect/flush", await this.getApiBaseUrl()), {
			method: "POST",
			body: responseBytes,
			headers
		});
		if (!resp.ok) {
			this.debug("Failed to flush messages", await resp.text());
			throw new Error("Failed to flush messages");
		}
		return FlushResponse.decode(new Uint8Array(await resp.arrayBuffer()));
	}
	async flush(hashedSigningKey) {
		if (Object.keys(this.buffered).length === 0) return;
		this.debug(`Flushing ${Object.keys(this.buffered).length} messages`);
		const maxAttempts = 5;
		for (let attempt = 0; attempt < maxAttempts; attempt++) {
			for (const [k, v] of Object.entries(this.buffered)) try {
				await this.sendFlushRequest(hashedSigningKey, v);
				delete this.buffered[k];
			} catch (err) {
				this.debug("Failed to flush message", k, err);
				break;
			}
			if (Object.keys(this.buffered).length === 0) return;
			await new Promise((resolve) => setTimeout(resolve, expBackoff(attempt)));
		}
		this.debug(`Failed to flush messages after max attempts`, { maxAttempts });
	}
};
function isUnsharedArrayBuffer(value) {
	if (typeof SharedArrayBuffer === "undefined") return true;
	return value.buffer instanceof ArrayBuffer;
}

//#endregion
export { MessageBuffer };
//# sourceMappingURL=buffer.js.map