import { SDKResponse } from "../../../../proto/src/components/connect/protobuf/connect.js";
import { MessageBuffer } from "../../buffer.js";
import { BaseStrategy } from "../core/BaseStrategy.js";
import { ConnectionCore } from "../core/connection.js";

//#region src/components/connect/strategies/sameThread/index.ts
const ResponseAcknowledgeDeadline = 5e3;
/**
* Same-thread connection strategy.
*
* This strategy runs the WebSocket connection, heartbeater, and lease extender
* in the same thread as user code execution. This is the default strategy.
*/
var SameThreadStrategy = class extends BaseStrategy {
	config;
	messageBuffer;
	core;
	constructor(config) {
		super();
		this.config = config;
		this.core = new ConnectionCore({
			apiBaseUrl: config.apiBaseUrl,
			appIds: Object.keys(config.requestHandlers),
			connectionData: config.connectionData,
			envName: config.envName,
			hashedFallbackKey: config.hashedFallbackKey,
			hashedSigningKey: config.hashedSigningKey,
			instanceId: config.options.instanceId,
			maxWorkerConcurrency: config.options.maxWorkerConcurrency,
			mode: config.mode,
			rewriteGatewayEndpoint: config.options.rewriteGatewayEndpoint
		}, {
			log: (message, data) => this.debugLog(message, data),
			onStateChange: (state) => {
				this._state = state;
			},
			getState: () => this._state,
			handleExecutionRequest: async (request) => {
				const handler = this.config.requestHandlers[request.appName];
				if (!handler) throw new Error(`No handler for app: ${request.appName}`);
				const response = await handler(request);
				const responseBytes = SDKResponse.encode(response).finish();
				this.messageBuffer.addPending(request.requestId, responseBytes, ResponseAcknowledgeDeadline);
				return responseBytes;
			},
			onReplyAck: (requestId) => {
				this.messageBuffer.acknowledgePending(requestId);
			},
			onBufferResponse: (requestId, responseBytes) => {
				this.messageBuffer.append(requestId, responseBytes);
			},
			beforeConnect: async (signingKey) => {
				await this.messageBuffer.flush(signingKey);
			}
		});
		this.messageBuffer = new MessageBuffer({
			envName: config.envName,
			getApiBaseUrl: () => this.core.getApiBaseUrl()
		});
	}
	get connectionId() {
		return this.core.connectionId;
	}
	async close() {
		this.cleanupShutdown();
		this.setClosing();
		this.debugLog("Cleaning up connection resources");
		await this.core.cleanup();
		this.debugLog("Connection closed");
		this.debugLog("Waiting for in-flight requests to complete");
		await this.core.waitForInProgress();
		this.debugLog("Flushing messages before closing");
		try {
			await this.messageBuffer.flush(this.config.hashedSigningKey);
		} catch (err) {
			this.debugLog("Failed to flush messages, using fallback key", err);
			await this.messageBuffer.flush(this.config.hashedFallbackKey);
		}
		this.setClosed();
		this.debugLog("Fully closed");
	}
	async connect(attempt = 0) {
		this.throwIfClosingOrClosed();
		this.setupShutdownSignalIfConfigured(this.config.options.handleShutdownSignals);
		try {
			await this.messageBuffer.flush(this.config.hashedSigningKey);
		} catch (err) {
			this.debugLog("Failed to flush messages, using fallback key", err);
			await this.messageBuffer.flush(this.config.hashedFallbackKey);
		}
		await this.core.connect(attempt);
	}
};

//#endregion
export { SameThreadStrategy };
//# sourceMappingURL=index.js.map