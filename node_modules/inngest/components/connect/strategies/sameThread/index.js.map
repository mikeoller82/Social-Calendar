{"version":3,"file":"index.js","names":[],"sources":["../../../../../src/components/connect/strategies/sameThread/index.ts"],"sourcesContent":["import { SDKResponse } from \"../../../../proto/src/components/connect/protobuf/connect.ts\";\nimport { MessageBuffer } from \"../../buffer.ts\";\nimport { BaseStrategy } from \"../core/BaseStrategy.ts\";\nimport { ConnectionCore } from \"../core/connection.ts\";\nimport type { StrategyConfig } from \"../core/types.ts\";\n\nconst ResponseAcknowledgeDeadline = 5_000;\n\n/**\n * Same-thread connection strategy.\n *\n * This strategy runs the WebSocket connection, heartbeater, and lease extender\n * in the same thread as user code execution. This is the default strategy.\n */\nexport class SameThreadStrategy extends BaseStrategy {\n  private readonly config: StrategyConfig;\n  private readonly messageBuffer: MessageBuffer;\n  private readonly core: ConnectionCore;\n\n  constructor(config: StrategyConfig) {\n    super();\n    this.config = config;\n\n    // Create the connection core with callbacks\n    this.core = new ConnectionCore(\n      {\n        apiBaseUrl: config.apiBaseUrl,\n        appIds: Object.keys(config.requestHandlers),\n        connectionData: config.connectionData,\n        envName: config.envName,\n        hashedFallbackKey: config.hashedFallbackKey,\n        hashedSigningKey: config.hashedSigningKey,\n        instanceId: config.options.instanceId,\n        maxWorkerConcurrency: config.options.maxWorkerConcurrency,\n        mode: config.mode,\n        rewriteGatewayEndpoint: config.options.rewriteGatewayEndpoint,\n      },\n      {\n        log: (message, data) => this.debugLog(message, data),\n        onStateChange: (state) => {\n          this._state = state;\n        },\n        getState: () => this._state,\n        handleExecutionRequest: async (request) => {\n          const handler = this.config.requestHandlers[request.appName];\n          if (!handler) {\n            throw new Error(`No handler for app: ${request.appName}`);\n          }\n          const response = await handler(request);\n          const responseBytes = SDKResponse.encode(response).finish();\n\n          // Add to pending with deadline\n          this.messageBuffer.addPending(\n            request.requestId,\n            responseBytes,\n            ResponseAcknowledgeDeadline,\n          );\n\n          return responseBytes;\n        },\n        onReplyAck: (requestId) => {\n          this.messageBuffer.acknowledgePending(requestId);\n        },\n        onBufferResponse: (requestId, responseBytes) => {\n          this.messageBuffer.append(requestId, responseBytes);\n        },\n        beforeConnect: async (signingKey) => {\n          await this.messageBuffer.flush(signingKey);\n        },\n      },\n    );\n\n    this.messageBuffer = new MessageBuffer({\n      envName: config.envName,\n      getApiBaseUrl: () => this.core.getApiBaseUrl(),\n    });\n  }\n\n  get connectionId(): string | undefined {\n    return this.core.connectionId;\n  }\n\n  async close(): Promise<void> {\n    this.cleanupShutdown();\n    this.setClosing();\n    this.debugLog(\"Cleaning up connection resources\");\n\n    await this.core.cleanup();\n\n    this.debugLog(\"Connection closed\");\n    this.debugLog(\"Waiting for in-flight requests to complete\");\n\n    await this.core.waitForInProgress();\n\n    this.debugLog(\"Flushing messages before closing\");\n\n    try {\n      await this.messageBuffer.flush(this.config.hashedSigningKey);\n    } catch (err) {\n      this.debugLog(\"Failed to flush messages, using fallback key\", err);\n      await this.messageBuffer.flush(this.config.hashedFallbackKey);\n    }\n\n    this.setClosed();\n    this.debugLog(\"Fully closed\");\n  }\n\n  async connect(attempt = 0): Promise<void> {\n    this.throwIfClosingOrClosed();\n    this.setupShutdownSignalIfConfigured(\n      this.config.options.handleShutdownSignals,\n    );\n\n    // Flush any pending messages before connecting\n    try {\n      await this.messageBuffer.flush(this.config.hashedSigningKey);\n    } catch (err) {\n      this.debugLog(\"Failed to flush messages, using fallback key\", err);\n      await this.messageBuffer.flush(this.config.hashedFallbackKey);\n    }\n\n    await this.core.connect(attempt);\n  }\n}\n"],"mappings":";;;;;;AAMA,MAAM,8BAA8B;;;;;;;AAQpC,IAAa,qBAAb,cAAwC,aAAa;CACnD,AAAiB;CACjB,AAAiB;CACjB,AAAiB;CAEjB,YAAY,QAAwB;AAClC,SAAO;AACP,OAAK,SAAS;AAGd,OAAK,OAAO,IAAI,eACd;GACE,YAAY,OAAO;GACnB,QAAQ,OAAO,KAAK,OAAO,gBAAgB;GAC3C,gBAAgB,OAAO;GACvB,SAAS,OAAO;GAChB,mBAAmB,OAAO;GAC1B,kBAAkB,OAAO;GACzB,YAAY,OAAO,QAAQ;GAC3B,sBAAsB,OAAO,QAAQ;GACrC,MAAM,OAAO;GACb,wBAAwB,OAAO,QAAQ;GACxC,EACD;GACE,MAAM,SAAS,SAAS,KAAK,SAAS,SAAS,KAAK;GACpD,gBAAgB,UAAU;AACxB,SAAK,SAAS;;GAEhB,gBAAgB,KAAK;GACrB,wBAAwB,OAAO,YAAY;IACzC,MAAM,UAAU,KAAK,OAAO,gBAAgB,QAAQ;AACpD,QAAI,CAAC,QACH,OAAM,IAAI,MAAM,uBAAuB,QAAQ,UAAU;IAE3D,MAAM,WAAW,MAAM,QAAQ,QAAQ;IACvC,MAAM,gBAAgB,YAAY,OAAO,SAAS,CAAC,QAAQ;AAG3D,SAAK,cAAc,WACjB,QAAQ,WACR,eACA,4BACD;AAED,WAAO;;GAET,aAAa,cAAc;AACzB,SAAK,cAAc,mBAAmB,UAAU;;GAElD,mBAAmB,WAAW,kBAAkB;AAC9C,SAAK,cAAc,OAAO,WAAW,cAAc;;GAErD,eAAe,OAAO,eAAe;AACnC,UAAM,KAAK,cAAc,MAAM,WAAW;;GAE7C,CACF;AAED,OAAK,gBAAgB,IAAI,cAAc;GACrC,SAAS,OAAO;GAChB,qBAAqB,KAAK,KAAK,eAAe;GAC/C,CAAC;;CAGJ,IAAI,eAAmC;AACrC,SAAO,KAAK,KAAK;;CAGnB,MAAM,QAAuB;AAC3B,OAAK,iBAAiB;AACtB,OAAK,YAAY;AACjB,OAAK,SAAS,mCAAmC;AAEjD,QAAM,KAAK,KAAK,SAAS;AAEzB,OAAK,SAAS,oBAAoB;AAClC,OAAK,SAAS,6CAA6C;AAE3D,QAAM,KAAK,KAAK,mBAAmB;AAEnC,OAAK,SAAS,mCAAmC;AAEjD,MAAI;AACF,SAAM,KAAK,cAAc,MAAM,KAAK,OAAO,iBAAiB;WACrD,KAAK;AACZ,QAAK,SAAS,gDAAgD,IAAI;AAClE,SAAM,KAAK,cAAc,MAAM,KAAK,OAAO,kBAAkB;;AAG/D,OAAK,WAAW;AAChB,OAAK,SAAS,eAAe;;CAG/B,MAAM,QAAQ,UAAU,GAAkB;AACxC,OAAK,wBAAwB;AAC7B,OAAK,gCACH,KAAK,OAAO,QAAQ,sBACrB;AAGD,MAAI;AACF,SAAM,KAAK,cAAc,MAAM,KAAK,OAAO,iBAAiB;WACrD,KAAK;AACZ,QAAK,SAAS,gDAAgD,IAAI;AAClE,SAAM,KAAK,cAAc,MAAM,KAAK,OAAO,kBAAkB;;AAG/D,QAAM,KAAK,KAAK,QAAQ,QAAQ"}