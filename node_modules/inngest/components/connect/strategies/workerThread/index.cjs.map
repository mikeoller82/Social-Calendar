{"version":3,"file":"index.cjs","names":["BaseStrategy","Worker","ConnectionState","GatewayExecutorRequestData","SDKResponse"],"sources":["../../../../../src/components/connect/strategies/workerThread/index.ts"],"sourcesContent":["/**\n * Worker thread connection strategy.\n *\n * This strategy runs the WebSocket connection, heartbeater, and lease extender\n * in a separate worker thread. Userland code execution still happens in the\n * main thread.\n */\n\nimport { dirname, extname, join } from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\nimport { Worker } from \"node:worker_threads\";\nimport {\n  GatewayExecutorRequestData,\n  SDKResponse,\n} from \"../../../../proto/src/components/connect/protobuf/connect.ts\";\nimport { ConnectionState } from \"../../types.ts\";\nimport { BaseStrategy } from \"../core/BaseStrategy.ts\";\nimport type { StrategyConfig } from \"../core/types.ts\";\nimport type {\n  MainToWorkerMessage,\n  SerializableConfig,\n  WorkerToMainMessage,\n} from \"./protocol.ts\";\n\n/**\n * Worker thread connection strategy.\n *\n * This strategy runs the WebSocket connection, heartbeater, and lease extender\n * in a separate Node.js worker thread. This prevents blocked user code from\n * interfering with connection health.\n */\nexport class WorkerThreadStrategy extends BaseStrategy {\n  private readonly config: StrategyConfig;\n  private worker: Worker | undefined;\n\n  private _connectionId: string | undefined;\n\n  constructor(config: StrategyConfig) {\n    super();\n    this.config = config;\n  }\n\n  get connectionId(): string | undefined {\n    return this._connectionId;\n  }\n\n  async close(): Promise<void> {\n    this.cleanupShutdown();\n    this.setClosing();\n    this.debugLog(\"Closing worker thread connection\");\n\n    if (this.worker) {\n      // Send close message to worker\n      this.sendToWorker({ type: \"CLOSE\" });\n\n      // Wait for worker to finish\n      await new Promise<void>((resolve) => {\n        if (!this.worker) {\n          resolve();\n          return;\n        }\n\n        const timeout = setTimeout(() => {\n          this.debugLog(\"Worker close timeout, terminating\");\n\n          // Force terminate the worker to avoid hanging. Ideally this should\n          // never happen, since the worker thread should've exited\n          this.worker?.terminate();\n          resolve();\n        }, 30_000);\n\n        this.worker.once(\"exit\", () => {\n          clearTimeout(timeout);\n          resolve();\n        });\n      });\n\n      this.worker = undefined;\n    }\n\n    this.setClosed();\n    this.debugLog(\"Worker thread connection closed\");\n  }\n\n  async connect(attempt = 0): Promise<void> {\n    this.throwIfClosingOrClosed();\n    this.debugLog(\"Starting worker thread connection\", { attempt });\n\n    this.setupShutdownSignalIfConfigured(\n      this.config.options.handleShutdownSignals,\n    );\n\n    // Create the worker thread\n    await this.createWorker();\n\n    // Initialize the worker with config\n    const serializableConfig = await this.buildSerializableConfig();\n    this.sendToWorker({ type: \"INIT\", config: serializableConfig });\n\n    // Wait for connection to be ready\n    await new Promise<void>((resolve, reject) => {\n      if (!this.worker) {\n        reject(new Error(\"Worker not created\"));\n        return;\n      }\n\n      const handleMessage = (msg: WorkerToMainMessage) => {\n        if (msg.type === \"CONNECTION_READY\") {\n          this._connectionId = msg.connectionId;\n          resolve();\n        } else if (msg.type === \"ERROR\" && msg.fatal) {\n          reject(new Error(msg.error));\n        }\n      };\n\n      this.worker.on(\"message\", handleMessage);\n\n      // Send connect command\n      this.sendToWorker({ type: \"CONNECT\", attempt });\n    });\n  }\n\n  private async createWorker(): Promise<void> {\n    // Get the path to the runner file\n    // Use the same extension as the current file (.ts in dev, .js in prod)\n    const currentFilePath = fileURLToPath(import.meta.url);\n    const ext = extname(currentFilePath);\n    const runnerPath = join(dirname(currentFilePath), `runner${ext}`);\n\n    this.debugLog(\"Creating worker thread\", { runnerPath });\n\n    // Create the worker with TypeScript support via tsx or ts-node\n    // In production builds, this will be JavaScript\n    this.worker = new Worker(runnerPath, {\n      // Inherit environment variables\n      env: process.env as NodeJS.ProcessEnv,\n    });\n\n    // Set up worker event handlers\n    this.worker.on(\"message\", (msg: WorkerToMainMessage) => {\n      this.handleWorkerMessage(msg);\n    });\n\n    this.worker.on(\"error\", (err) => {\n      this.debugLog(\"Worker error\", err.message);\n      this._state = ConnectionState.RECONNECTING;\n    });\n\n    this.worker.on(\"exit\", (code) => {\n      this.debugLog(\"Worker exited\", { code });\n      if (\n        this._state !== ConnectionState.CLOSING &&\n        this._state !== ConnectionState.CLOSED\n      ) {\n        this._state = ConnectionState.RECONNECTING;\n        // Attempt to recreate and reconnect\n        this.createWorker()\n          .then(async () => {\n            const config = await this.buildSerializableConfig();\n            this.sendToWorker({ type: \"INIT\", config });\n            this.sendToWorker({ type: \"CONNECT\", attempt: 0 });\n          })\n          .catch((err) => {\n            this.debugLog(\"Failed to recreate worker\", err);\n          });\n      }\n    });\n  }\n\n  private handleWorkerMessage(msg: WorkerToMainMessage): void {\n    switch (msg.type) {\n      case \"STATE_CHANGE\":\n        this._state = msg.state;\n        this.debugLog(\"State changed\", { state: msg.state });\n        break;\n\n      case \"CONNECTION_READY\":\n        this._connectionId = msg.connectionId;\n        this.debugLog(\"Connection ready\", { connectionId: msg.connectionId });\n        break;\n\n      case \"ERROR\":\n        if (msg.fatal) {\n          this.debugLog(\"Fatal error from worker\", { error: msg.error });\n        } else {\n          console.error(`[inngest] ${msg.error}`);\n        }\n        break;\n\n      case \"EXECUTION_REQUEST\":\n        this.handleExecutionRequest(msg.requestId, msg.request);\n        break;\n\n      case \"CLOSED\":\n        this._state = ConnectionState.CLOSED;\n        this.resolveClosingPromise?.();\n        break;\n\n      case \"LOG\":\n        this.handleWorkerLog(msg.level, msg.message, msg.data);\n        break;\n    }\n  }\n\n  private handleWorkerLog(\n    level: \"debug\" | \"info\" | \"warn\" | \"error\",\n    message: string,\n    data?: unknown,\n  ): void {\n    // If data is nullish, set it to an empty string. This avoids seeing `null`\n    // and `undefined` in logs\n    data = data ?? \"\";\n\n    switch (level) {\n      case \"debug\":\n        this.debugLog(message, data);\n        break;\n      case \"info\":\n        console.log(`[inngest] ${message}`, data);\n        break;\n      case \"warn\":\n        console.warn(`[inngest] ${message}`, data);\n        break;\n      case \"error\":\n        console.error(`[inngest] ${message}`, data);\n        break;\n    }\n  }\n\n  private async handleExecutionRequest(\n    requestId: string,\n    requestBytes: Uint8Array,\n  ): Promise<void> {\n    try {\n      // Decode the request\n      const gatewayExecutorRequest =\n        GatewayExecutorRequestData.decode(requestBytes);\n\n      // Find the request handler\n      const requestHandler =\n        this.config.requestHandlers[gatewayExecutorRequest.appName];\n\n      if (!requestHandler) {\n        this.debugLog(\"No handler for app\", {\n          appName: gatewayExecutorRequest.appName,\n        });\n        this.sendToWorker({\n          type: \"EXECUTION_ERROR\",\n          requestId,\n          error: `No handler for app: ${gatewayExecutorRequest.appName}`,\n        });\n        return;\n      }\n\n      // Execute the handler in the main thread\n      const response = await requestHandler(gatewayExecutorRequest);\n\n      // Encode and send response back to worker\n      const responseBytes = SDKResponse.encode(response).finish();\n      this.sendToWorker({\n        type: \"EXECUTION_RESPONSE\",\n        requestId,\n        response: responseBytes,\n      });\n    } catch (err) {\n      this.debugLog(\"Execution error\", {\n        requestId,\n        error: err instanceof Error ? err.message : err,\n      });\n      this.sendToWorker({\n        type: \"EXECUTION_ERROR\",\n        requestId,\n        error: err instanceof Error ? err.message : \"Unknown error\",\n      });\n    }\n  }\n\n  private sendToWorker(msg: MainToWorkerMessage): void {\n    if (!this.worker) {\n      this.debugLog(\"Cannot send message, no worker\");\n      return;\n    }\n    this.worker.postMessage(msg);\n  }\n\n  private async buildSerializableConfig(): Promise<SerializableConfig> {\n    if (this.config.options.rewriteGatewayEndpoint) {\n      // TODO: Figure out how to support this. Currently, we don't support it\n      throw new Error(\n        \"rewriteGatewayEndpoint is not supported in worker threads\",\n      );\n    }\n\n    return {\n      apiBaseUrl: this.config.apiBaseUrl,\n      appIds: Object.keys(this.config.requestHandlers),\n      connectionData: this.config.connectionData,\n      envName: this.config.envName,\n      handleShutdownSignals: this.config.options.handleShutdownSignals,\n      hashedFallbackKey: this.config.hashedFallbackKey,\n      hashedSigningKey: this.config.hashedSigningKey,\n      instanceId: this.config.options.instanceId,\n      maxWorkerConcurrency: this.config.options.maxWorkerConcurrency,\n      mode: {\n        isDev: this.config.mode.isDev,\n        isInferred: this.config.mode.isInferred,\n      },\n    };\n  }\n}\n"],"mappings":"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"}