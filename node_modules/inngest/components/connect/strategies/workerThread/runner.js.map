{"version":3,"file":"runner.js","names":[],"sources":["../../../../../src/components/connect/strategies/workerThread/runner.ts"],"sourcesContent":["/**\n * Worker thread runner for Inngest Connect.\n *\n * This file runs in a separate worker thread and manages:\n * - WebSocket connection to the Inngest gateway\n * - Heartbeater\n * - Lease extender\n *\n * Userland code execution still happens in the main thread.\n */\n\nimport { isMainThread, parentPort } from \"node:worker_threads\";\nimport { GatewayExecutorRequestData } from \"../../../../proto/src/components/connect/protobuf/connect.ts\";\nimport { MessageBuffer } from \"../../buffer.ts\";\nimport { ConnectionState } from \"../../types.ts\";\nimport { ConnectionCore } from \"../core/connection.ts\";\nimport type {\n  MainToWorkerMessage,\n  SerializableConfig,\n  WorkerToMainMessage,\n} from \"./protocol.ts\";\n\n/**\n * Time in milliseconds to wait for gateway acknowledgment of a response.\n * If no ACK is received within this deadline, the response is moved to the\n * buffer for later flush via HTTP.\n */\nconst responseAcknowledgeDeadline = 5_000;\n\nif (isMainThread) {\n  throw new Error(\"This file should only be run in a worker thread\");\n}\n\nif (!parentPort) {\n  throw new Error(\"No parent port available\");\n}\n\n/**\n * Worker thread runner state.\n */\nclass WorkerRunner {\n  private config: SerializableConfig | undefined;\n  private state: ConnectionState = ConnectionState.CONNECTING;\n  private core: ConnectionCore | undefined;\n  private messageBuffer: MessageBuffer | undefined;\n\n  /**\n   * Pending execution responses waiting for user code to complete.\n   */\n  private pendingExecutions: Map<\n    string,\n    {\n      resolve: (response: Uint8Array) => void;\n      reject: (error: Error) => void;\n    }\n  > = new Map();\n\n  private sendMessage(msg: WorkerToMainMessage) {\n    parentPort?.postMessage(msg);\n  }\n\n  private log(message: string, data?: unknown) {\n    this.sendMessage({ type: \"LOG\", level: \"debug\", message, data });\n  }\n\n  private setState(state: ConnectionState) {\n    this.state = state;\n    this.sendMessage({ type: \"STATE_CHANGE\", state });\n  }\n\n  handleMessage(msg: MainToWorkerMessage) {\n    switch (msg.type) {\n      case \"INIT\":\n        this.config = msg.config;\n        this.initializeCore();\n        this.log(\"Worker initialized with config\");\n        break;\n\n      case \"CONNECT\":\n        if (!this.core) {\n          this.sendMessage({\n            type: \"ERROR\",\n            error: \"Worker not initialized\",\n            fatal: true,\n          });\n          return;\n        }\n        this.core.connect(msg.attempt).catch((err) => {\n          this.sendMessage({\n            type: \"ERROR\",\n            error: err instanceof Error ? err.message : \"Unknown error\",\n            fatal: true,\n          });\n        });\n        break;\n\n      case \"CLOSE\":\n        this.close().catch((err) => {\n          this.log(\n            \"Error during close\",\n            err instanceof Error ? err.message : err,\n          );\n        });\n        break;\n\n      case \"EXECUTION_RESPONSE\": {\n        const pending = this.pendingExecutions.get(msg.requestId);\n        if (pending) {\n          pending.resolve(msg.response);\n          this.pendingExecutions.delete(msg.requestId);\n        }\n        break;\n      }\n\n      case \"EXECUTION_ERROR\": {\n        const pending = this.pendingExecutions.get(msg.requestId);\n        if (pending) {\n          pending.reject(new Error(msg.error));\n          this.pendingExecutions.delete(msg.requestId);\n        }\n        break;\n      }\n    }\n  }\n\n  private initializeCore() {\n    if (!this.config) {\n      throw new Error(\"Config not set\");\n    }\n\n    this.core = new ConnectionCore(\n      {\n        ...this.config,\n\n        // TODO: Figure out how to support this. Currently, we don't support it\n        // because functions can't be passed to worker threads (since they\n        // aren't serializable)\n        rewriteGatewayEndpoint: undefined,\n      },\n      {\n        log: (message, data) => this.log(message, data),\n        onStateChange: (state) => {\n          this.setState(state);\n          if (state === ConnectionState.ACTIVE && this.core?.connectionId) {\n            this.sendMessage({\n              type: \"CONNECTION_READY\",\n              connectionId: this.core.connectionId,\n            });\n          }\n        },\n        getState: () => this.state,\n        handleExecutionRequest: async (request) => {\n          // Send execution request to main thread and wait for response\n          const requestPromise = new Promise<Uint8Array>((resolve, reject) => {\n            this.pendingExecutions.set(request.requestId, { resolve, reject });\n          });\n\n          // Send the request to main thread (as serialized bytes)\n          this.sendMessage({\n            type: \"EXECUTION_REQUEST\",\n            requestId: request.requestId,\n            request: GatewayExecutorRequestData.encode(request).finish(),\n          });\n\n          // Wait for main thread to complete execution\n          const responseBytes = await requestPromise;\n\n          // Add to pending with deadline for acknowledgment tracking\n          this.messageBuffer?.addPending(\n            request.requestId,\n            responseBytes,\n            responseAcknowledgeDeadline,\n          );\n\n          return responseBytes;\n        },\n        onReplyAck: (requestId) => {\n          this.messageBuffer?.acknowledgePending(requestId);\n        },\n        onBufferResponse: (requestId, responseBytes) => {\n          this.messageBuffer?.append(requestId, responseBytes);\n        },\n        beforeConnect: async (signingKey) => {\n          await this.messageBuffer?.flush(signingKey);\n        },\n      },\n    );\n\n    // Create message buffer for buffering responses when connection is lost\n    this.messageBuffer = new MessageBuffer({\n      envName: this.config.envName,\n      getApiBaseUrl: () => this.core!.getApiBaseUrl(),\n    });\n  }\n\n  async close(): Promise<void> {\n    this.setState(ConnectionState.CLOSING);\n    this.log(\"Cleaning up connection resources\");\n\n    if (this.core) {\n      await this.core.cleanup();\n    }\n\n    this.log(\"Connection closed\");\n    this.log(\"Waiting for in-flight requests to complete\");\n\n    if (this.core) {\n      await this.core.waitForInProgress();\n    }\n\n    this.log(\"Flushing messages before closing\");\n\n    if (this.messageBuffer) {\n      try {\n        await this.messageBuffer.flush(this.config?.hashedSigningKey);\n      } catch (err) {\n        this.log(\n          \"Failed to flush messages, using fallback key\",\n          err instanceof Error ? err.message : err,\n        );\n        await this.messageBuffer.flush(this.config?.hashedFallbackKey);\n      }\n    }\n\n    this.setState(ConnectionState.CLOSED);\n\n    this.sendMessage({ type: \"CLOSED\" });\n    this.log(\"Fully closed\");\n\n    // Exit the worker thread. Without this, the parentPort message listener\n    // keeps the event loop alive and the worker never exits.\n    process.exit(0);\n  }\n}\n\n// Initialize the worker runner\nconst runner = new WorkerRunner();\n\n// Listen for messages from the main thread\nparentPort.on(\"message\", (msg: MainToWorkerMessage) => {\n  runner.handleMessage(msg);\n});\n"],"mappings":"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"}