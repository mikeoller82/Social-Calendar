const require_rolldown_runtime = require('../../../../_virtual/rolldown_runtime.cjs');
const require_connect = require('../../../../proto/src/components/connect/protobuf/connect.cjs');
const require_types = require('../../types.cjs');
const require_BaseStrategy = require('../core/BaseStrategy.cjs');
let node_url = require("node:url");
let node_worker_threads = require("node:worker_threads");
let node_path = require("node:path");

//#region src/components/connect/strategies/workerThread/index.ts
/**
* Worker thread connection strategy.
*
* This strategy runs the WebSocket connection, heartbeater, and lease extender
* in a separate worker thread. Userland code execution still happens in the
* main thread.
*/
/**
* Worker thread connection strategy.
*
* This strategy runs the WebSocket connection, heartbeater, and lease extender
* in a separate Node.js worker thread. This prevents blocked user code from
* interfering with connection health.
*/
var WorkerThreadStrategy = class extends require_BaseStrategy.BaseStrategy {
	config;
	worker;
	_connectionId;
	constructor(config) {
		super();
		this.config = config;
	}
	get connectionId() {
		return this._connectionId;
	}
	async close() {
		this.cleanupShutdown();
		this.setClosing();
		this.debugLog("Closing worker thread connection");
		if (this.worker) {
			this.sendToWorker({ type: "CLOSE" });
			await new Promise((resolve) => {
				if (!this.worker) {
					resolve();
					return;
				}
				const timeout = setTimeout(() => {
					this.debugLog("Worker close timeout, terminating");
					this.worker?.terminate();
					resolve();
				}, 3e4);
				this.worker.once("exit", () => {
					clearTimeout(timeout);
					resolve();
				});
			});
			this.worker = void 0;
		}
		this.setClosed();
		this.debugLog("Worker thread connection closed");
	}
	async connect(attempt = 0) {
		this.throwIfClosingOrClosed();
		this.debugLog("Starting worker thread connection", { attempt });
		this.setupShutdownSignalIfConfigured(this.config.options.handleShutdownSignals);
		await this.createWorker();
		const serializableConfig = await this.buildSerializableConfig();
		this.sendToWorker({
			type: "INIT",
			config: serializableConfig
		});
		await new Promise((resolve, reject) => {
			if (!this.worker) {
				reject(/* @__PURE__ */ new Error("Worker not created"));
				return;
			}
			const handleMessage = (msg) => {
				if (msg.type === "CONNECTION_READY") {
					this._connectionId = msg.connectionId;
					resolve();
				} else if (msg.type === "ERROR" && msg.fatal) reject(new Error(msg.error));
			};
			this.worker.on("message", handleMessage);
			this.sendToWorker({
				type: "CONNECT",
				attempt
			});
		});
	}
	async createWorker() {
		const currentFilePath = (0, node_url.fileURLToPath)(require("url").pathToFileURL(__filename).href);
		const ext = (0, node_path.extname)(currentFilePath);
		const runnerPath = (0, node_path.join)((0, node_path.dirname)(currentFilePath), `runner${ext}`);
		this.debugLog("Creating worker thread", { runnerPath });
		this.worker = new node_worker_threads.Worker(runnerPath, { env: process.env });
		this.worker.on("message", (msg) => {
			this.handleWorkerMessage(msg);
		});
		this.worker.on("error", (err) => {
			this.debugLog("Worker error", err.message);
			this._state = require_types.ConnectionState.RECONNECTING;
		});
		this.worker.on("exit", (code) => {
			this.debugLog("Worker exited", { code });
			if (this._state !== require_types.ConnectionState.CLOSING && this._state !== require_types.ConnectionState.CLOSED) {
				this._state = require_types.ConnectionState.RECONNECTING;
				this.createWorker().then(async () => {
					const config = await this.buildSerializableConfig();
					this.sendToWorker({
						type: "INIT",
						config
					});
					this.sendToWorker({
						type: "CONNECT",
						attempt: 0
					});
				}).catch((err) => {
					this.debugLog("Failed to recreate worker", err);
				});
			}
		});
	}
	handleWorkerMessage(msg) {
		switch (msg.type) {
			case "STATE_CHANGE":
				this._state = msg.state;
				this.debugLog("State changed", { state: msg.state });
				break;
			case "CONNECTION_READY":
				this._connectionId = msg.connectionId;
				this.debugLog("Connection ready", { connectionId: msg.connectionId });
				break;
			case "ERROR":
				if (msg.fatal) this.debugLog("Fatal error from worker", { error: msg.error });
				else console.error(`[inngest] ${msg.error}`);
				break;
			case "EXECUTION_REQUEST":
				this.handleExecutionRequest(msg.requestId, msg.request);
				break;
			case "CLOSED":
				this._state = require_types.ConnectionState.CLOSED;
				this.resolveClosingPromise?.();
				break;
			case "LOG":
				this.handleWorkerLog(msg.level, msg.message, msg.data);
				break;
		}
	}
	handleWorkerLog(level, message, data) {
		data = data ?? "";
		switch (level) {
			case "debug":
				this.debugLog(message, data);
				break;
			case "info":
				console.log(`[inngest] ${message}`, data);
				break;
			case "warn":
				console.warn(`[inngest] ${message}`, data);
				break;
			case "error":
				console.error(`[inngest] ${message}`, data);
				break;
		}
	}
	async handleExecutionRequest(requestId, requestBytes) {
		try {
			const gatewayExecutorRequest = require_connect.GatewayExecutorRequestData.decode(requestBytes);
			const requestHandler = this.config.requestHandlers[gatewayExecutorRequest.appName];
			if (!requestHandler) {
				this.debugLog("No handler for app", { appName: gatewayExecutorRequest.appName });
				this.sendToWorker({
					type: "EXECUTION_ERROR",
					requestId,
					error: `No handler for app: ${gatewayExecutorRequest.appName}`
				});
				return;
			}
			const response = await requestHandler(gatewayExecutorRequest);
			const responseBytes = require_connect.SDKResponse.encode(response).finish();
			this.sendToWorker({
				type: "EXECUTION_RESPONSE",
				requestId,
				response: responseBytes
			});
		} catch (err) {
			this.debugLog("Execution error", {
				requestId,
				error: err instanceof Error ? err.message : err
			});
			this.sendToWorker({
				type: "EXECUTION_ERROR",
				requestId,
				error: err instanceof Error ? err.message : "Unknown error"
			});
		}
	}
	sendToWorker(msg) {
		if (!this.worker) {
			this.debugLog("Cannot send message, no worker");
			return;
		}
		this.worker.postMessage(msg);
	}
	async buildSerializableConfig() {
		if (this.config.options.rewriteGatewayEndpoint) throw new Error("rewriteGatewayEndpoint is not supported in worker threads");
		return {
			apiBaseUrl: this.config.apiBaseUrl,
			appIds: Object.keys(this.config.requestHandlers),
			connectionData: this.config.connectionData,
			envName: this.config.envName,
			handleShutdownSignals: this.config.options.handleShutdownSignals,
			hashedFallbackKey: this.config.hashedFallbackKey,
			hashedSigningKey: this.config.hashedSigningKey,
			instanceId: this.config.options.instanceId,
			maxWorkerConcurrency: this.config.options.maxWorkerConcurrency,
			mode: {
				isDev: this.config.mode.isDev,
				isInferred: this.config.mode.isInferred
			}
		};
	}
};

//#endregion
exports.WorkerThreadStrategy = WorkerThreadStrategy;
//# sourceMappingURL=index.cjs.map