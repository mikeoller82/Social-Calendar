{"version":3,"file":"index.cjs","names":["functions: Record<\n      string,\n      {\n        client: Inngest.Like;\n        functions: InngestFunction.Any[];\n      }\n    >","DEFAULT_SHUTDOWN_SIGNALS","allProcessEnv","envKeys","ConnectionState","getEnvironmentName","hashSigningKey","capabilities: Capabilities","functionConfigs: Record<\n      string,\n      {\n        client: Inngest.Like;\n        functions: FunctionConfig[];\n      }\n    >","connectionData: ConnectionEstablishData","requestHandlers: Record<string, RequestHandler>","InngestCommHandler","parseFnData","parseTraceCtx","headerKeys","sdkResponseStatus: SDKResponseStatus","SDKResponseStatus","SDKResponse","version","PREFERRED_ASYNC_EXECUTION_VERSION","queryKeys","createStrategy"],"sources":["../../../src/components/connect/index.ts"],"sourcesContent":["import debug from \"debug\";\nimport { envKeys, headerKeys, queryKeys } from \"../../helpers/consts.ts\";\nimport { allProcessEnv, getEnvironmentName } from \"../../helpers/env.ts\";\nimport { parseFnData } from \"../../helpers/functions.ts\";\nimport { hashSigningKey } from \"../../helpers/strings.ts\";\nimport {\n  type GatewayExecutorRequestData,\n  SDKResponse,\n  SDKResponseStatus,\n} from \"../../proto/src/components/connect/protobuf/connect.ts\";\nimport type { Capabilities, FunctionConfig } from \"../../types.ts\";\nimport { version } from \"../../version.ts\";\nimport { PREFERRED_ASYNC_EXECUTION_VERSION } from \"../execution/InngestExecution.ts\";\nimport type { Inngest } from \"../Inngest.ts\";\nimport { InngestCommHandler } from \"../InngestCommHandler.ts\";\nimport type { InngestFunction } from \"../InngestFunction.ts\";\nimport {\n  type ConnectionEstablishData,\n  type ConnectionStrategy,\n  createStrategy,\n  type RequestHandler,\n} from \"./strategies/index.ts\";\nimport {\n  type ConnectApp,\n  type ConnectHandlerOptions,\n  ConnectionState,\n  DEFAULT_SHUTDOWN_SIGNALS,\n  type WorkerConnection,\n} from \"./types.ts\";\nimport { parseTraceCtx } from \"./util.ts\";\n\nconst InngestBranchEnvironmentSigningKeyPrefix = \"signkey-branch-\";\n\ntype ConnectCommHandler = InngestCommHandler<\n  [GatewayExecutorRequestData],\n  SDKResponse,\n  // biome-ignore lint/suspicious/noExplicitAny: intentional\n  any\n>;\n\n/**\n * WebSocket worker connection that implements the WorkerConnection interface.\n *\n * This class acts as a facade that delegates to a connection strategy.\n * The strategy determines how the WebSocket connection, heartbeater, and\n * lease extender are managed (same thread vs worker thread).\n */\nclass WebSocketWorkerConnection implements WorkerConnection {\n  private inngest: Inngest.Any;\n  private options: ConnectHandlerOptions;\n  private strategy: ConnectionStrategy | undefined;\n  private debugLog = debug(\"inngest:connect\");\n\n  constructor(options: ConnectHandlerOptions) {\n    if (\n      !Array.isArray(options.apps) ||\n      options.apps.length === 0 ||\n      !options.apps[0]\n    ) {\n      throw new Error(\"No apps provided\");\n    }\n\n    this.inngest = options.apps[0].client as Inngest.Any;\n    for (const app of options.apps) {\n      const client = app.client as Inngest.Any;\n\n      if (client.env !== this.inngest.env) {\n        throw new Error(\n          `All apps must be configured to the same environment. ${client.id} is configured to ${client.env} but ${this.inngest.id} is configured to ${this.inngest.env}`,\n        );\n      }\n    }\n\n    this.options = this.applyDefaults(options);\n  }\n\n  private get functions(): Record<\n    string,\n    {\n      client: Inngest.Like;\n      functions: InngestFunction.Any[];\n    }\n  > {\n    const functions: Record<\n      string,\n      {\n        client: Inngest.Like;\n        functions: InngestFunction.Any[];\n      }\n    > = {};\n    for (const app of this.options.apps) {\n      const client = app.client as Inngest.Any;\n\n      if (functions[client.id]) {\n        throw new Error(`Duplicate app id: ${client.id}`);\n      }\n\n      functions[client.id] = {\n        client: app.client,\n        functions: (app.functions as InngestFunction.Any[]) ?? client.funcs,\n      };\n    }\n    return functions;\n  }\n\n  private applyDefaults(opts: ConnectHandlerOptions): ConnectHandlerOptions {\n    const options = { ...opts };\n    if (!Array.isArray(options.handleShutdownSignals)) {\n      options.handleShutdownSignals = DEFAULT_SHUTDOWN_SIGNALS;\n    }\n\n    const env = allProcessEnv();\n    options.signingKey = options.signingKey || env[envKeys.InngestSigningKey];\n    options.signingKeyFallback =\n      options.signingKeyFallback || env[envKeys.InngestSigningKeyFallback];\n\n    if (options.maxWorkerConcurrency === undefined) {\n      const envValue = env[envKeys.InngestConnectMaxWorkerConcurrency];\n      if (envValue) {\n        const parsed = Number.parseInt(envValue, 10);\n        if (!Number.isNaN(parsed) && parsed > 0) {\n          options.maxWorkerConcurrency = parsed;\n        }\n      }\n    }\n\n    // Check for worker thread env var\n    if (options.isolateExecution === undefined) {\n      const envValue = env[envKeys.InngestConnectIsolateExecution];\n      if (envValue === \"1\" || envValue === \"true\") {\n        options.isolateExecution = true;\n      }\n    }\n\n    return options;\n  }\n\n  get state(): ConnectionState {\n    return this.strategy?.state ?? ConnectionState.CONNECTING;\n  }\n\n  get connectionId(): string {\n    if (!this.strategy?.connectionId) {\n      throw new Error(\"Connection not prepared\");\n    }\n    return this.strategy.connectionId;\n  }\n\n  get closed(): Promise<void> {\n    if (!this.strategy) {\n      throw new Error(\"No connection established\");\n    }\n    return this.strategy.closed;\n  }\n\n  async close(): Promise<void> {\n    if (!this.strategy) {\n      return;\n    }\n    return this.strategy.close();\n  }\n\n  /**\n   * Establish a persistent connection to the gateway.\n   */\n  async connect(attempt = 0): Promise<void> {\n    this.debugLog(\"Establishing connection\", { attempt });\n\n    const envName = this.inngest.env ?? getEnvironmentName();\n\n    if (this.inngest[\"mode\"].isCloud && !this.options.signingKey) {\n      throw new Error(\"Signing key is required\");\n    }\n\n    const hashedSigningKey = this.options.signingKey\n      ? hashSigningKey(this.options.signingKey)\n      : undefined;\n\n    if (\n      this.options.signingKey &&\n      this.options.signingKey.startsWith(\n        InngestBranchEnvironmentSigningKeyPrefix,\n      ) &&\n      !envName\n    ) {\n      throw new Error(\n        \"Environment is required when using branch environment signing keys\",\n      );\n    }\n\n    const hashedFallbackKey = this.options.signingKeyFallback\n      ? hashSigningKey(this.options.signingKeyFallback)\n      : undefined;\n\n    // Build capabilities\n    const capabilities: Capabilities = {\n      trust_probe: \"v1\",\n      connect: \"v1\",\n    };\n\n    // Build function configs\n    const functionConfigs: Record<\n      string,\n      {\n        client: Inngest.Like;\n        functions: FunctionConfig[];\n      }\n    > = {};\n    for (const [appId, { client, functions }] of Object.entries(\n      this.functions,\n    )) {\n      functionConfigs[appId] = {\n        client: client,\n        functions: functions.flatMap((f) =>\n          f[\"getConfig\"]({\n            baseUrl: new URL(\"wss://connect\"),\n            appPrefix: (client as Inngest.Any).id,\n            isConnect: true,\n          }),\n        ),\n      };\n    }\n\n    this.debugLog(\"Prepared sync data\", {\n      functionSlugs: Object.entries(functionConfigs).map(\n        ([appId, { functions }]) => {\n          return JSON.stringify({\n            appId,\n            functions: functions.map((f) => ({\n              id: f.id,\n              stepUrls: Object.values(f.steps).map((s) => s.runtime[\"url\"]),\n            })),\n          });\n        },\n      ),\n    });\n\n    // Build connection establish data\n    const connectionData: ConnectionEstablishData = {\n      manualReadinessAck: false,\n      marshaledCapabilities: JSON.stringify(capabilities),\n      apps: Object.entries(functionConfigs).map(\n        ([appId, { client, functions }]) => ({\n          appName: appId,\n          appVersion: (client as Inngest.Any).appVersion,\n          functions: new TextEncoder().encode(JSON.stringify(functions)),\n        }),\n      ),\n    };\n\n    // Build request handlers\n    const requestHandlers: Record<string, RequestHandler> = {};\n    for (const [appId, { client, functions }] of Object.entries(\n      this.functions,\n    )) {\n      const inngestCommHandler: ConnectCommHandler = new InngestCommHandler({\n        client: client,\n        functions: functions,\n        frameworkName: \"connect\",\n        signingKey: this.options.signingKey,\n        signingKeyFallback: this.options.signingKeyFallback,\n        skipSignatureValidation: true,\n        handler: (msg: GatewayExecutorRequestData) => {\n          const asString = new TextDecoder().decode(msg.requestPayload);\n          const parsed = parseFnData(JSON.parse(asString));\n\n          const userTraceCtx = parseTraceCtx(msg.userTraceCtx);\n\n          return {\n            body() {\n              return parsed;\n            },\n            method() {\n              return \"POST\";\n            },\n            headers(key) {\n              switch (key) {\n                case headerKeys.ContentLength.toString():\n                  return asString.length.toString();\n                case headerKeys.InngestExpectedServerKind.toString():\n                  return \"connect\";\n                case headerKeys.RequestVersion.toString():\n                  return parsed.version.toString();\n                case headerKeys.Signature.toString():\n                  return null;\n                case headerKeys.TraceParent.toString():\n                  return userTraceCtx?.traceParent ?? null;\n                case headerKeys.TraceState.toString():\n                  return userTraceCtx?.traceState ?? null;\n                default:\n                  return null;\n              }\n            },\n            transformResponse({ body, headers, status }) {\n              let sdkResponseStatus: SDKResponseStatus = SDKResponseStatus.DONE;\n              switch (status) {\n                case 200:\n                  sdkResponseStatus = SDKResponseStatus.DONE;\n                  break;\n                case 206:\n                  sdkResponseStatus = SDKResponseStatus.NOT_COMPLETED;\n                  break;\n                case 500:\n                  sdkResponseStatus = SDKResponseStatus.ERROR;\n                  break;\n              }\n\n              return SDKResponse.create({\n                requestId: msg.requestId,\n                accountId: msg.accountId,\n                envId: msg.envId,\n                appId: msg.appId,\n                status: sdkResponseStatus,\n                body: new TextEncoder().encode(body),\n                noRetry: headers[headerKeys.NoRetry] === \"true\",\n                retryAfter: headers[headerKeys.RetryAfter],\n                sdkVersion: `inngest-js:v${version}`,\n                requestVersion: parseInt(\n                  headers[headerKeys.RequestVersion] ??\n                    PREFERRED_ASYNC_EXECUTION_VERSION.toString(),\n                  10,\n                ),\n                systemTraceCtx: msg.systemTraceCtx,\n                userTraceCtx: msg.userTraceCtx,\n                runId: msg.runId,\n              });\n            },\n            url() {\n              const baseUrl = new URL(\"http://connect.inngest.com\");\n\n              baseUrl.searchParams.set(queryKeys.FnId, msg.functionSlug);\n\n              if (msg.stepId) {\n                baseUrl.searchParams.set(queryKeys.StepId, msg.stepId);\n              }\n\n              return baseUrl;\n            },\n          };\n        },\n      });\n      const requestHandler = inngestCommHandler.createHandler();\n      requestHandlers[appId] = requestHandler;\n    }\n\n    // Create and initialize the strategy\n    this.strategy = await createStrategy(\n      {\n        hashedSigningKey,\n        hashedFallbackKey,\n        envName,\n        connectionData,\n        requestHandlers,\n        options: this.options,\n        apiBaseUrl: this.inngest.apiBaseUrl,\n        mode: this.inngest[\"mode\"],\n      },\n      this.options,\n    );\n\n    // Delegate to the strategy\n    await this.strategy.connect(attempt);\n  }\n}\n\n// Export types for convenience\nexport {\n  DEFAULT_SHUTDOWN_SIGNALS,\n  type ConnectApp,\n  type ConnectHandlerOptions,\n  ConnectionState,\n  type WorkerConnection,\n};\n\nexport const connect = async (\n  options: ConnectHandlerOptions,\n): Promise<WorkerConnection> => {\n  if (options.apps.length === 0) {\n    throw new Error(\"No apps provided\");\n  }\n\n  const conn = new WebSocketWorkerConnection(options);\n\n  await conn.connect();\n\n  return conn;\n};\n"],"mappings":"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"}